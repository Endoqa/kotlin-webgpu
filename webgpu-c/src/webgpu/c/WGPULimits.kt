// this file is auto generated by endoqa kotlin ffi, modify it with caution
package webgpu.c

import java.lang.foreign.Arena
import java.lang.foreign.MemoryLayout
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.StructLayout
import java.lang.foreign.ValueLayout
import java.lang.invoke.VarHandle
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.UInt
import kotlin.ULong
import kotlin.jvm.JvmField
import kotlin.jvm.JvmInline
import kotlin.jvm.JvmStatic

@JvmInline
public value class WGPULimits(
    public val `$mem`: MemorySegment,
) {
    public var nextInChain: Pointer<WGPUChainedStructOut>
        get() = WGPULimits.nextInChainHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            WGPULimits.nextInChainHandle.set(this.`$mem`, 0L, value)
        }

    public var maxTextureDimension1D: UInt
        get() = (WGPULimits.maxTextureDimension1DHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxTextureDimension1DHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxTextureDimension2D: UInt
        get() = (WGPULimits.maxTextureDimension2DHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxTextureDimension2DHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxTextureDimension3D: UInt
        get() = (WGPULimits.maxTextureDimension3DHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxTextureDimension3DHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxTextureArrayLayers: UInt
        get() = (WGPULimits.maxTextureArrayLayersHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxTextureArrayLayersHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxBindGroups: UInt
        get() = (WGPULimits.maxBindGroupsHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxBindGroupsHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxBindGroupsPlusVertexBuffers: UInt
        get() = (WGPULimits.maxBindGroupsPlusVertexBuffersHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxBindGroupsPlusVertexBuffersHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxBindingsPerBindGroup: UInt
        get() = (WGPULimits.maxBindingsPerBindGroupHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxBindingsPerBindGroupHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxDynamicUniformBuffersPerPipelineLayout: UInt
        get() = (WGPULimits.maxDynamicUniformBuffersPerPipelineLayoutHandle.get(this.`$mem`, 0L) as
                Int).toUInt()
        set(`value`) {
            WGPULimits.maxDynamicUniformBuffersPerPipelineLayoutHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxDynamicStorageBuffersPerPipelineLayout: UInt
        get() = (WGPULimits.maxDynamicStorageBuffersPerPipelineLayoutHandle.get(this.`$mem`, 0L) as
                Int).toUInt()
        set(`value`) {
            WGPULimits.maxDynamicStorageBuffersPerPipelineLayoutHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxSampledTexturesPerShaderStage: UInt
        get() = (WGPULimits.maxSampledTexturesPerShaderStageHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxSampledTexturesPerShaderStageHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxSamplersPerShaderStage: UInt
        get() = (WGPULimits.maxSamplersPerShaderStageHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxSamplersPerShaderStageHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxStorageBuffersPerShaderStage: UInt
        get() = (WGPULimits.maxStorageBuffersPerShaderStageHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxStorageBuffersPerShaderStageHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxStorageTexturesPerShaderStage: UInt
        get() = (WGPULimits.maxStorageTexturesPerShaderStageHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxStorageTexturesPerShaderStageHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxUniformBuffersPerShaderStage: UInt
        get() = (WGPULimits.maxUniformBuffersPerShaderStageHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxUniformBuffersPerShaderStageHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxUniformBufferBindingSize: ULong
        get() = (WGPULimits.maxUniformBufferBindingSizeHandle.get(this.`$mem`, 0L) as Long).toULong()
        set(`value`) {
            WGPULimits.maxUniformBufferBindingSizeHandle.set(this.`$mem`, 0L, value.toLong())
        }

    public var maxStorageBufferBindingSize: ULong
        get() = (WGPULimits.maxStorageBufferBindingSizeHandle.get(this.`$mem`, 0L) as Long).toULong()
        set(`value`) {
            WGPULimits.maxStorageBufferBindingSizeHandle.set(this.`$mem`, 0L, value.toLong())
        }

    public var minUniformBufferOffsetAlignment: UInt
        get() = (WGPULimits.minUniformBufferOffsetAlignmentHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.minUniformBufferOffsetAlignmentHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var minStorageBufferOffsetAlignment: UInt
        get() = (WGPULimits.minStorageBufferOffsetAlignmentHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.minStorageBufferOffsetAlignmentHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxVertexBuffers: UInt
        get() = (WGPULimits.maxVertexBuffersHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxVertexBuffersHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxBufferSize: ULong
        get() = (WGPULimits.maxBufferSizeHandle.get(this.`$mem`, 0L) as Long).toULong()
        set(`value`) {
            WGPULimits.maxBufferSizeHandle.set(this.`$mem`, 0L, value.toLong())
        }

    public var maxVertexAttributes: UInt
        get() = (WGPULimits.maxVertexAttributesHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxVertexAttributesHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxVertexBufferArrayStride: UInt
        get() = (WGPULimits.maxVertexBufferArrayStrideHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxVertexBufferArrayStrideHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxInterStageShaderVariables: UInt
        get() = (WGPULimits.maxInterStageShaderVariablesHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxInterStageShaderVariablesHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxColorAttachments: UInt
        get() = (WGPULimits.maxColorAttachmentsHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxColorAttachmentsHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxColorAttachmentBytesPerSample: UInt
        get() = (WGPULimits.maxColorAttachmentBytesPerSampleHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxColorAttachmentBytesPerSampleHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeWorkgroupStorageSize: UInt
        get() = (WGPULimits.maxComputeWorkgroupStorageSizeHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeWorkgroupStorageSizeHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeInvocationsPerWorkgroup: UInt
        get() = (WGPULimits.maxComputeInvocationsPerWorkgroupHandle.get(this.`$mem`, 0L) as
                Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeInvocationsPerWorkgroupHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeWorkgroupSizeX: UInt
        get() = (WGPULimits.maxComputeWorkgroupSizeXHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeWorkgroupSizeXHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeWorkgroupSizeY: UInt
        get() = (WGPULimits.maxComputeWorkgroupSizeYHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeWorkgroupSizeYHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeWorkgroupSizeZ: UInt
        get() = (WGPULimits.maxComputeWorkgroupSizeZHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeWorkgroupSizeZHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public var maxComputeWorkgroupsPerDimension: UInt
        get() = (WGPULimits.maxComputeWorkgroupsPerDimensionHandle.get(this.`$mem`, 0L) as Int).toUInt()
        set(`value`) {
            WGPULimits.maxComputeWorkgroupsPerDimensionHandle.set(this.`$mem`, 0L, value.toInt())
        }

    public constructor(gc: Boolean) : this(kotlin.run {
        require(gc) { "Do not call this if gc is not want" }
        Arena.ofAuto().allocate(WGPULimits.layout)
    })

    public companion object {
        public val layout: StructLayout = MemoryLayout.structLayout(
            `$RuntimeHelper`.POINTER.withName("nextInChain"),
            ValueLayout.JAVA_INT.withName("maxTextureDimension1D"),
            ValueLayout.JAVA_INT.withName("maxTextureDimension2D"),
            ValueLayout.JAVA_INT.withName("maxTextureDimension3D"),
            ValueLayout.JAVA_INT.withName("maxTextureArrayLayers"),
            ValueLayout.JAVA_INT.withName("maxBindGroups"),
            ValueLayout.JAVA_INT.withName("maxBindGroupsPlusVertexBuffers"),
            ValueLayout.JAVA_INT.withName("maxBindingsPerBindGroup"),
            ValueLayout.JAVA_INT.withName("maxDynamicUniformBuffersPerPipelineLayout"),
            ValueLayout.JAVA_INT.withName("maxDynamicStorageBuffersPerPipelineLayout"),
            ValueLayout.JAVA_INT.withName("maxSampledTexturesPerShaderStage"),
            ValueLayout.JAVA_INT.withName("maxSamplersPerShaderStage"),
            ValueLayout.JAVA_INT.withName("maxStorageBuffersPerShaderStage"),
            ValueLayout.JAVA_INT.withName("maxStorageTexturesPerShaderStage"),
            ValueLayout.JAVA_INT.withName("maxUniformBuffersPerShaderStage"),
            ValueLayout.JAVA_LONG.withName("maxUniformBufferBindingSize"),
            ValueLayout.JAVA_LONG.withName("maxStorageBufferBindingSize"),
            ValueLayout.JAVA_INT.withName("minUniformBufferOffsetAlignment"),
            ValueLayout.JAVA_INT.withName("minStorageBufferOffsetAlignment"),
            ValueLayout.JAVA_INT.withName("maxVertexBuffers"),
            java.lang.foreign.MemoryLayout.paddingLayout(4),
            ValueLayout.JAVA_LONG.withName("maxBufferSize"),
            ValueLayout.JAVA_INT.withName("maxVertexAttributes"),
            ValueLayout.JAVA_INT.withName("maxVertexBufferArrayStride"),
            ValueLayout.JAVA_INT.withName("maxInterStageShaderVariables"),
            ValueLayout.JAVA_INT.withName("maxColorAttachments"),
            ValueLayout.JAVA_INT.withName("maxColorAttachmentBytesPerSample"),
            ValueLayout.JAVA_INT.withName("maxComputeWorkgroupStorageSize"),
            ValueLayout.JAVA_INT.withName("maxComputeInvocationsPerWorkgroup"),
            ValueLayout.JAVA_INT.withName("maxComputeWorkgroupSizeX"),
            ValueLayout.JAVA_INT.withName("maxComputeWorkgroupSizeY"),
            ValueLayout.JAVA_INT.withName("maxComputeWorkgroupSizeZ"),
            ValueLayout.JAVA_INT.withName("maxComputeWorkgroupsPerDimension"),
            java.lang.foreign.MemoryLayout.paddingLayout(4),
        ).withName("WGPULimits")

        @JvmField
        public val nextInChainHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("nextInChain"))

        @JvmField
        public val maxTextureDimension1DHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxTextureDimension1D"))

        @JvmField
        public val maxTextureDimension2DHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxTextureDimension2D"))

        @JvmField
        public val maxTextureDimension3DHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxTextureDimension3D"))

        @JvmField
        public val maxTextureArrayLayersHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxTextureArrayLayers"))

        @JvmField
        public val maxBindGroupsHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxBindGroups"))

        @JvmField
        public val maxBindGroupsPlusVertexBuffersHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxBindGroupsPlusVertexBuffers"))

        @JvmField
        public val maxBindingsPerBindGroupHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxBindingsPerBindGroup"))

        @JvmField
        public val maxDynamicUniformBuffersPerPipelineLayoutHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxDynamicUniformBuffersPerPipelineLayout"))

        @JvmField
        public val maxDynamicStorageBuffersPerPipelineLayoutHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxDynamicStorageBuffersPerPipelineLayout"))

        @JvmField
        public val maxSampledTexturesPerShaderStageHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxSampledTexturesPerShaderStage"))

        @JvmField
        public val maxSamplersPerShaderStageHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxSamplersPerShaderStage"))

        @JvmField
        public val maxStorageBuffersPerShaderStageHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxStorageBuffersPerShaderStage"))

        @JvmField
        public val maxStorageTexturesPerShaderStageHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxStorageTexturesPerShaderStage"))

        @JvmField
        public val maxUniformBuffersPerShaderStageHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxUniformBuffersPerShaderStage"))

        @JvmField
        public val maxUniformBufferBindingSizeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxUniformBufferBindingSize"))

        @JvmField
        public val maxStorageBufferBindingSizeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxStorageBufferBindingSize"))

        @JvmField
        public val minUniformBufferOffsetAlignmentHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("minUniformBufferOffsetAlignment"))

        @JvmField
        public val minStorageBufferOffsetAlignmentHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("minStorageBufferOffsetAlignment"))

        @JvmField
        public val maxVertexBuffersHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxVertexBuffers"))

        @JvmField
        public val maxBufferSizeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxBufferSize"))

        @JvmField
        public val maxVertexAttributesHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxVertexAttributes"))

        @JvmField
        public val maxVertexBufferArrayStrideHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxVertexBufferArrayStride"))

        @JvmField
        public val maxInterStageShaderVariablesHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxInterStageShaderVariables"))

        @JvmField
        public val maxColorAttachmentsHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxColorAttachments"))

        @JvmField
        public val maxColorAttachmentBytesPerSampleHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxColorAttachmentBytesPerSample"))

        @JvmField
        public val maxComputeWorkgroupStorageSizeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeWorkgroupStorageSize"))

        @JvmField
        public val maxComputeInvocationsPerWorkgroupHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeInvocationsPerWorkgroup"))

        @JvmField
        public val maxComputeWorkgroupSizeXHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeWorkgroupSizeX"))

        @JvmField
        public val maxComputeWorkgroupSizeYHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeWorkgroupSizeY"))

        @JvmField
        public val maxComputeWorkgroupSizeZHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeWorkgroupSizeZ"))

        @JvmField
        public val maxComputeWorkgroupsPerDimensionHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("maxComputeWorkgroupsPerDimension"))

        @JvmStatic
        public fun allocate(alloc: SegmentAllocator): WGPULimits =
            WGPULimits(alloc.allocate(WGPULimits.layout))
    }
}
